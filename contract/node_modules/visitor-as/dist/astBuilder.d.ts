/// <reference types="assemblyscript/std/portable" />
import { TypeNode, Node, Source, NamedTypeNode, FunctionTypeNode, TypeParameterNode, IdentifierExpression, CallExpression, ClassExpression, ElementAccessExpression, FunctionExpression, InstanceOfExpression, LiteralExpression, NewExpression, ParenthesizedExpression, PropertyAccessExpression, TernaryExpression, UnaryPostfixExpression, UnaryPrefixExpression, BlockStatement, BreakStatement, ContinueStatement, DoStatement, EmptyStatement, ExportStatement, ExportDefaultStatement, ExportImportStatement, ExpressionStatement, ForStatement, IfStatement, ImportStatement, ReturnStatement, SwitchStatement, ThrowStatement, TryStatement, VariableStatement, WhileStatement, ClassDeclaration, EnumDeclaration, EnumValueDeclaration, FieldDeclaration, FunctionDeclaration, ImportDeclaration, InterfaceDeclaration, MethodDeclaration, NamespaceDeclaration, TypeDeclaration, VariableDeclaration, DecoratorNode, ExportMember, ParameterNode, SwitchCase, TypeName, ArrayLiteralExpression, ObjectLiteralExpression, FloatLiteralExpression, StringLiteralExpression, RegexpLiteralExpression, UnaryExpression, DeclarationStatement, AssertionExpression, BinaryExpression, CommaExpression, IntegerLiteralExpression, ForOfStatement, IndexSignatureNode, TemplateLiteralExpression } from "../as";
import { AbstractVisitor } from "./visitor";
/** An AST builder. */
export declare class ASTBuilder extends AbstractVisitor<Node> {
    _visit(node: Node): void;
    /** Rebuilds the textual source from the specified AST, as far as possible. */
    static build(node: Node): string;
    private sb;
    private indentLevel;
    visitNode(node: Node): void;
    visitSource(source: Source): void;
    visitTypeNode(node: TypeNode): void;
    visitTypeName(node: TypeName): void;
    visitNamedTypeNode(node: NamedTypeNode): void;
    visitFunctionTypeNode(node: FunctionTypeNode): void;
    visitTypeParameter(node: TypeParameterNode): void;
    visitIdentifierExpression(node: IdentifierExpression): void;
    visitArrayLiteralExpression(node: ArrayLiteralExpression): void;
    visitObjectLiteralExpression(node: ObjectLiteralExpression): void;
    visitAssertionExpression(node: AssertionExpression): void;
    visitBinaryExpression(node: BinaryExpression): void;
    visitCallExpression(node: CallExpression): void;
    private visitArguments;
    visitClassExpression(node: ClassExpression): void;
    visitCommaExpression(node: CommaExpression): void;
    visitElementAccessExpression(node: ElementAccessExpression): void;
    visitFunctionExpression(node: FunctionExpression): void;
    visitLiteralExpression(node: LiteralExpression): void;
    visitFloatLiteralExpression(node: FloatLiteralExpression): void;
    visitInstanceOfExpression(node: InstanceOfExpression): void;
    visitIntegerLiteralExpression(node: IntegerLiteralExpression): void;
    visitStringLiteral(str: string): void;
    private visitRawString;
    visitStringLiteralExpression(node: StringLiteralExpression): void;
    visitTemplateLiteralExpression(node: TemplateLiteralExpression): void;
    visitRegexpLiteralExpression(node: RegexpLiteralExpression): void;
    visitNewExpression(node: NewExpression): void;
    visitParenthesizedExpression(node: ParenthesizedExpression): void;
    visitPropertyAccessExpression(node: PropertyAccessExpression): void;
    visitTernaryExpression(node: TernaryExpression): void;
    visitUnaryExpression(node: UnaryExpression): void;
    visitUnaryPostfixExpression(node: UnaryPostfixExpression): void;
    visitUnaryPrefixExpression(node: UnaryPrefixExpression): void;
    visitNodeAndTerminate(node: Node): void;
    visitBlockStatement(node: BlockStatement): void;
    visitBreakStatement(node: BreakStatement): void;
    visitContinueStatement(node: ContinueStatement): void;
    visitClassDeclaration(node: ClassDeclaration, isDefault?: bool): void;
    visitDoStatement(node: DoStatement): void;
    visitEmptyStatement(node: EmptyStatement): void;
    visitEnumDeclaration(node: EnumDeclaration, isDefault?: bool): void;
    visitEnumValueDeclaration(node: EnumValueDeclaration): void;
    visitExportImportStatement(node: ExportImportStatement): void;
    visitExportMember(node: ExportMember): void;
    visitExportStatement(node: ExportStatement): void;
    visitExportDefaultStatement(node: ExportDefaultStatement): void;
    visitExpressionStatement(node: ExpressionStatement): void;
    visitFieldDeclaration(node: FieldDeclaration): void;
    visitForStatement(node: ForStatement): void;
    visitForOfStatement(node: ForOfStatement): void;
    visitFunctionDeclaration(node: FunctionDeclaration, isDefault?: bool): void;
    visitFunctionCommon(node: FunctionDeclaration): void;
    visitIfStatement(node: IfStatement): void;
    visitImportDeclaration(node: ImportDeclaration): void;
    visitImportStatement(node: ImportStatement): void;
    visitIndexSignature(node: IndexSignatureNode): void;
    visitInterfaceDeclaration(node: InterfaceDeclaration, isDefault?: bool): void;
    visitMethodDeclaration(node: MethodDeclaration): void;
    visitNamespaceDeclaration(node: NamespaceDeclaration, isDefault?: bool): void;
    visitReturnStatement(node: ReturnStatement): void;
    visitSwitchCase(node: SwitchCase): void;
    visitSwitchStatement(node: SwitchStatement): void;
    visitThrowStatement(node: ThrowStatement): void;
    visitTryStatement(node: TryStatement): void;
    visitTypeDeclaration(node: TypeDeclaration): void;
    visitVariableDeclaration(node: VariableDeclaration): void;
    visitVariableStatement(node: VariableStatement): void;
    visitWhileStatement(node: WhileStatement): void;
    serializeDecorator(node: DecoratorNode): void;
    serializeParameter(node: ParameterNode): void;
    serializeExternalModifiers(node: DeclarationStatement): void;
    serializeAccessModifiers(node: DeclarationStatement): void;
    finish(): string;
}
